#!/usr/bin/env bash

region=$(aws configure get region)

if [[ $region == "" ]] ; then
  echo "Please configure your AWS deployment region by running: aws configure"
  exit 1
fi

nargs=$#

if [[ nargs -eq 0 ]]; then
  echo "Available commmands (look inside the script to get a better idea of what they do):"
  echo

  # Finds the commands by inspecting the code

  list=$(grep '"[^"]\+" '$'\051' $0)

  IFS=$'\n'
  for i in $list; do
    echo -ne "- \e[1;37m$(echo $i | cut -d\" -f 2)\e[0m"
    echo -e "\e[33m$(echo $i | awk -F '# args:' '{print $2}')\e[0m"
  done
fi

args () {
  if [[ $(($nargs-1)) -lt $1 ]]; then
    echo "This command requires $1 argument(s)"
    exit 1
  fi
}

get_stack_name () {
  grep stack_name samconfig.toml | cut -d\" -f 2
}

case $1 in
  "list-functions" )
    aws lambda list-functions --output json
    ;;

  "list-apis" )
    aws apigateway get-rest-apis --output json
    ;;

  "list-api-ids" )
    $0 list-apis | jq -r ".items[].id"
    ;;

  "list-api-stages" ) # args: [api-id]
    api=${2:-$($0 list-api-ids | head -1)}
    aws apigateway get-stages --rest-api-id $api
    ;;

  "list-api-stage-names" ) # args: [api-id]
    api=${2:-$($0 list-api-ids | head -1)}
    $0 list-api-stages $api | jq -r '.item[] | .stageName'
    ;;

  "list-api-urls" )
    for api in $($0 list-api-ids); do
      for stage in $($0 list-api-stage-names $api); do
        echo https://$api.execute-api.$region.amazonaws.com/$stage/
      done
    done
    ;;

  "list-rds-dbs" )
    aws rds describe-db-instances --output json
    ;;

  "list-rds-db-ids" )
    $0 list-rds-dbs | jq -r ".DBInstances[].DBInstanceIdentifier"
    ;;

  "list-rds-db-endpoints" )
    $0 list-rds-dbs | jq -r ".DBInstances[].Endpoint"
    ;;

  "list-rds-postgres-versions" )
    for ver in $(aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion" --output=text); do
      echo $ver
    done
    ;;

  "list-rds-db-instance-options" )
    aws rds describe-orderable-db-instance-options --engine postgres --engine-version 13.3 --query "*[].{DBInstanceClass:DBInstanceClass,StorageType:StorageType}|[?StorageType=='gp2']|[].{DBInstanceClass:DBInstanceClass}" --output text
    ;;

  "list-stacks" )
    aws cloudformation describe-stacks --output json
    ;;

  "function-run" ) # args: func-name, [...params]
    args 1

    name=$2
    shift 2

    out=$(mktemp)
    res=$(aws lambda invoke --function-name $name $out "$@")

    echo Execution status:
    echo
    echo $res | jq .
    echo
    echo Function response: [raw: $out]
    echo

    status=$(cat $out | jq -r '.statusCode // empty')

    if [ -z $status ]; then
      cat $out | jq .
    else
      echo HTTP code: $status
      echo
      cat $out | jq '.body | fromjson'
    fi
    ;;

  "function-logs" ) # args: func-name
    args 1

    logstreams=$(aws logs describe-log-streams --log-group-name "/aws/lambda/$2" --query 'logStreams[*].logStreamName' | jq -r '.[-1]')

    if [ -z $logstreams ] ; then
      echo
      echo "No logs for this function"
    else
      for i in $logstreams; do
        aws logs get-log-events --log-group-name "/aws/lambda/$2" --log-stream-name $i | jq '.events[]'
      done
    fi
    ;;

  "rds-db-action" ) # args: action [instance-id]
    args 1

    if [ -z $3 ]; then
      ids=$($0 list-rds-db-ids)

      if [ -z "$ids" ]; then
        echo No databases found
      elif [ $(echo "$ids" | wc -l) -gt 1 ]; then
        echo Found more than one database, please specify an instance id:
        echo
        echo "$ids"
      else
        id="$ids"
      fi
    else
      id=$3
    fi

    if [ -n "$id" ]; then
      aws rds $2 --db-instance-identifier $id
    else
      exit 1
    fi
    ;;

  "rds-db-status" ) # args: [instance-id]
    if [ -n "$2" ]; then
      id="--db-instance-identifier $2"
    fi

    res=$(aws rds describe-db-instances $id)

    echo $(echo $res | jq -r '.DBInstances[].DBName'): $(echo $res | jq -r '.DBInstances[].DBInstanceStatus')
    ;;

  "rds-db-hibernate" ) # args: [instance-id]
    status=$($0 rds-db-action stop-db-instance $2 | jq -r '.DBInstance.DBInstanceStatus')

    echo Status: $status
    echo
    echo This may take a while
    echo
    echo Check the status with: $0 rds-db-status
    ;;

  "rds-db-wake" ) # args: [instance-id]
    status=$($0 rds-db-action start-db-instance $2 | jq -r '.DBInstance.DBInstanceStatus')

    echo Status: $status
    echo
    echo This may take a while
    echo
    echo Check the status with: $0 rds-db-status
    ;;

  "rds-db-init" )
    $0 function-run db-init

    echo
    echo Don\'t forget to run \`sam deploy -g\` and set the value of the geometry type OID
    ;;

  "rds-db-run" ) # args: query, [user]
    args 1

    # Disable filename expansion so that the SQL query will be accepted verbatim
    set -f

    a1="\"query\":\"$(echo $2 | sed 's/"/\\"/g')\""
    [ $# -ge 3 ] && a2=",\"user\": \"$3\""

    json="{$a1$a2}"

    echo Invoking query function with parameters:
    echo
    echo $json | jq .
    echo

    $0 function-run db-run --payload "$json"
    ;;

  "rds-db-run-file" ) # args: query-file
    args 1

    echo Invoking query function with parameters:
    echo
    cat $2 | jq .
    echo

    $0 function-run db-run --payload fileb://$2
    ;;

  "rds-db-get-security-group" )
    aws rds describe-db-instances | jq -r ".DBInstances[].VpcSecurityGroups[].VpcSecurityGroupId"
    ;;

  "rds-db-authorize-ingress" )
    sg=$($0 rds-db-get-security-group)
    aws ec2 authorize-security-group-ingress --group-id $sg --protocol tcp --port 5432 --cidr 0.0.0.0/0
    ;;

  "rds-db-deauthorize-ingress" )
    sg=$($0 rds-db-get-security-group)
    aws ec2 revoke-security-group-ingress --group-id $sg --protocol tcp --port 5432 --cidr 0.0.0.0/0
    ;;

  "s3-list-object-tags" ) # args: bucket-name object-key
    aws s3api get-object-tagging --bucket $2 --key $3
    ;;

  "s3-delete-all" ) # args: bucket-name
    aws s3 rm s3://$2 --recursive
    ;;

  "event-log-table-info" )
    aws dynamodb describe-table --table-name littermap-events
    ;;

  "event-log-table-schema" )
    $0 event-log-table-info | jq .
    ;;

  "event-log" ) # args: [utc-date]
    # Convert today or given UTC date to epoch time
    date=$(date --date=${2:-$(date --utc +"%Y-%m-%d")} --utc +%s)

    aws dynamodb query --table-name event-log --key-condition-expression 'date_key = :date' --expression-attribute-values "{\":date\": {\"S\": \"$date\"}}" --scan-index-forward | jq -r '.Items[] | [.timestamp.S, .event.M.message.S] | join(" :: ")'
    ;;

  "stack-cancel-update" ) # args: [stack-name]
    aws cloudformation cancel-update-stack --stack-name ${2:-$(get_stack_name)}
    ;;

  "stack-delete" ) # args: [stack-name]
    sam delete --stack-name ${2:-$(get_stack_name)}
    ;;

  "api-export" ) # args: [api-id] [stage]
    out=$(mktemp)
    api=${2:-$($0 list-api-ids | head -1)}
    stage=${3:-$($0 list-api-stage-names $api | head -1)}
    aws apigateway get-export --rest-api-id $api --stage-name $stage --export-type oas30 $out

    cat $out
    ;;

  "make-password" )
    aws secretsmanager get-random-password --output=text
    ;;

  "make-rds-db-password" )
    # As per documented constraints for RDS passwords, replace quotes with |,
    # @ with # and / with \, and then also escape \ as \\
    echo $($0 make-password) | tr '/@"'"'" '\\#||' | sed 's/\\/\\\\/g'
    ;;

  "check-service-quotas" )
    service=$2

    if [ -z $service ]; then
      # List services with service quotas
      aws service-quotas list-services | jq -r ".Services[].ServiceCode"
    else
      aws service-quotas list-service-quotas --service-code $service
    fi
    ;;

  "lint" )
    if ! command -v jshint &>/dev/null ; then
      echo Install jshint to use this command
    else
      jshint $(find functions/ -name '*.js')
    fi
    ;;

  "www-prepare" ) # args: [git-ref]
    if ! command -v pnpm &>/dev/null; then
      echo Please install 'pnpm': https://pnpm.io
      exit 1
    fi

    ref=${2:-master}

    rm -rf publish/

    git clone git@github.com:earthstewards/littermap.git publish
    cd publish
    echo

    git reset $ref --hard
    echo

    pnpm install
    echo

    echo Please configure the front-end in publish/ before publishing
    ;;

  "www-update" ) # args: [git-ref]
    if [ ! -d publish ]; then
      echo First acquire a copy of the front-end repository by running: "$0 www-prepare"
      exit 1
    fi

    ref=${2:-master}

    cd publish
    git reset --hard
    echo
    git pull
    echo
    git reset $ref --hard
    echo

    pnpm install
    echo

    echo Check the configuration and then publish the website
    ;;

  "www-publish" )
    cd publish

    pnpm run build

    if [ $? -ne 0 ]; then
      echo
      echo Build failed
      exit 1
    fi

    echo
    echo -n Looking for S3 bucket that hosts the website...

    bucket=$(aws s3 ls | grep website | awk '{ print $3 }')

    if [ "$bucket" = "" ]; then
      echo " not found."
      echo
      echo Could not publish the website because the hosting S3 bucket was not found

      exit 1
    else
      echo
      echo
    fi

    echo Uploading files to S3 bucket: $bucket
    echo

    aws s3 sync --acl public-read --cache-control 'max-age=604800' build/ s3://$bucket --exclude index.html
    aws s3 sync --acl public-read --cache-control 'no-cache'       build/ s3://$bucket

    echo
    echo Website files published to: https://$bucket.s3.amazonaws.com
    ;;

  * )
    echo "Command $1 not available"
    ;;
esac
