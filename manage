#!/usr/bin/env sh

region=$(aws configure get region)

if [[ $region == "" ]] ; then
  echo "Please configure your AWS deployment region by running: aws configure"
  exit
fi

nargs=$#

if [[ nargs -eq 0 ]]; then
  echo "Available commmands (look inside the script to get a better idea of what they do):"
  echo

  # Finds the commands by inspecting the code

  list=$(grep '"[^"]\+" '$'\051' $0)

  IFS=$'\n'
  for i in $list; do
    echo -ne "- \e[1;37m$(echo $i | cut -d\" -f 2)\e[0m"
    echo -e "\e[33m$(echo $i | awk -F '# args:' '{print $2}')\e[0m"
  done

  exit
fi

args () {
  if [[ $(($nargs-1)) -lt $1 ]]; then
    echo "This command requires $1 argument(s)"
    exit
  fi
}

get_stack_name () {
  grep stack_name samconfig.toml | cut -d\" -f 2
}

case $1 in
  "list-functions" )
    aws lambda list-functions --output json
    ;;

  "list-apis" )
    aws apigateway get-rest-apis --output json
    ;;

  "list-api-urls" )
    apis=$($0 list-apis | jq -r ".items[].id")

    for api in $apis ; do
      for stage in $(aws apigateway get-stages --rest-api-id $api | jq -r ".item[].stageName"); do
        echo https://$api.execute-api.$region.amazonaws.com/$stage/
      done
    done
    ;;

  "list-rds-dbs" )
    aws rds describe-db-instances --output json
    ;;

  "list-rds-db-endpoints" )
    $0 list-rds-dbs | jq -r ".DBInstances[].Endpoint"
    ;;

  "list-rds-postgres-versions" )
    for ver in $(aws rds describe-db-engine-versions --engine postgres --query "DBEngineVersions[].EngineVersion" --output=text); do
      echo $ver
    done
    ;;

  "list-rds-db-instance-options" )
    aws rds describe-orderable-db-instance-options --engine postgres --engine-version 13.3 --query "*[].{DBInstanceClass:DBInstanceClass,StorageType:StorageType}|[?StorageType=='gp2']|[].{DBInstanceClass:DBInstanceClass}" --output text
    ;;

  "list-stacks" )
    aws cloudformation describe-stacks --output json
    ;;

  "function-run" ) # args: func-name, [...params]
    args 1

    name=$2
    shift 2

    out=$(mktemp)
    res=$(aws lambda invoke --function-name $name $out "$@")

    echo Execution status:
    echo
    echo $res | jq .
    echo
    echo Function response: [raw: $out]
    echo

    status=$(cat $out | jq -r '.statusCode // empty')

    if [ -z $status ]; then
      cat $out | jq .
    else
      echo HTTP code: $status
      echo
      cat $out | jq '.body | fromjson'
    fi
    ;;

  "function-logs" ) # args: func-name
    args 1

    logstream=$(aws logs describe-log-streams --log-group-name "/aws/lambda/$2" --query 'logStreams[*].logStreamName' --output=text | head -n 1)

    aws logs get-log-events --log-group-name "/aws/lambda/$2" --log-stream-name $logstream
    ;;

  "rds-db-hibernate-instance" ) # args: instance-id
    args 1
    aws rds stop-db-instance --db-instance-identifier $2
    ;;

  "rds-db-wake-instance" ) # args: instance-id
    args 1
    aws rds start-db-instance --db-instance-identifier $2
    ;;

  "rds-db-init" )
    $0 function-run db-init
    ;;

  "rds-db-run" ) # args: query, [user]
    args 1

    # Disable filename expansion so that the SQL query will be accepted verbatim
    set -f

    a1="\"query\":\"$(echo $2 | sed 's/"/\\"/g')\""
    [ $# -ge 3 ] && a2=",\"user\": \"$3\""

    json="{$a1$a2}"

    echo Invoking query function with parameters:
    echo
    echo $json | jq .
    echo

    $0 function-run db-run --payload "$json"
    ;;

  "rds-db-run-file" ) # args: query-file
    args 1

    echo Invoking query function with parameters:
    echo
    cat $2 | jq .
    echo

    $0 function-run db-run --payload fileb://$2
    ;;

  "rds-db-get-security-group" )
    aws rds describe-db-instances | jq -r ".DBInstances[].VpcSecurityGroups[].VpcSecurityGroupId"
    ;;

  "rds-db-authorize-ingress" )
    sg=$($0 rds-db-get-security-group)
    aws ec2 authorize-security-group-ingress --group-id $sg --protocol tcp --port 5432 --cidr 0.0.0.0/0
    ;;

  "rds-db-deauthorize-ingress" )
    sg=$($0 rds-db-get-security-group)
    aws ec2 revoke-security-group-ingress --group-id $sg --protocol tcp --port 5432 --cidr 0.0.0.0/0
    ;;

  "event-log-table-info" )
    aws dynamodb describe-table --table-name littermap-events
    ;;

  "event-log-table-schema" )
    $0 event-log-table-info | jq .
    ;;

  "event-log" ) # args: [utc-date]
    # Convert today or given UTC date to epoch time
    date=$(date --date=${2:-$(date --utc +"%Y-%m-%d")} --utc +%s)

    aws dynamodb query --table-name littermap-events --key-condition-expression 'date_key = :date' --expression-attribute-values "{\":date\": {\"S\": \"$date\"}}" --scan-index-forward --output=text | sed 1d
    ;;

  "stack-cancel-update" ) # args: [stack-name]
    aws cloudformation cancel-update-stack --stack-name ${2:-$(get_stack_name)}
    ;;

  "stack-delete" ) # args: [stack-name]
    sam delete --stack-name ${2:-$(get_stack_name)}
    ;;

  "make-password" )
    aws secretsmanager get-random-password --output=text
    ;;

  "make-rds-db-password" )
    # As per documented constraints for RDS passwords, replace quotes with |,
    # @ with # and / with \, and then also escape \ as \\
    echo $($0 make-password) | tr '/@"'"'" '\\#||' | sed 's/\\/\\\\/g'
    ;;

  "check-service-quotas" )
    service=$2

    if [ -z $service ]; then
      # List services with service quotas
      aws service-quotas list-services | jq -r ".Services[].ServiceCode"
    else
      aws service-quotas list-service-quotas --service-code $service
    fi
    ;;

  * )
    echo "Command $1 not available"
    ;;
esac
